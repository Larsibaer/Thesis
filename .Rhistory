) %>%
select(set, new, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
# One-hot encode
one_hot_encode <- function(df, columns) {
# Ensure 'columns' is a character vector
if(!is.character(columns)) {
stop("columns argument must be a character vector specifying column names to encode")
}
# Check if specified columns exist in the dataframe
if(!all(columns %in% names(df))) {
stop("Not all specified columns exist in the dataframe")
}
# Start with the original dataframe minus the columns to be encoded
result_df <- df[, !(names(df) %in% columns)]
# Iterate over the columns and perform one-hot encoding
for(column in columns) {
# Create a temporary dataframe to avoid altering the original data
temp_df <- data.frame(df[[column]], stringsAsFactors = FALSE)
colnames(temp_df) <- column
# Apply model.matrix(), remove intercept column, and convert to dataframe
encoded_matrix <- model.matrix(~ . - 1, data = temp_df)
encoded_df <- data.frame(encoded_matrix)
# Rename encoded columns to include original column name for clarity
colnames(encoded_df) <- gsub("X", column, colnames(encoded_df))
# Combine with the result dataframe
result_df <- cbind(result_df, encoded_df)
}
return(cbind(df[1], result_df))
}
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "new")
encoded_df_assignment_group <- one_hot_encode(data_assignment_group, "old")
encoded_df_assignment_group <- one_hot_encode(data_assignment_group, "new")
encoded_df_assigned_to <- one_hot_encode(data_assigned_to, "new")
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
select(set, new, old, percentage_time_diff) %>%
ungroup()
}
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
View(data_state)
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
# One-hot encode
one_hot_encode <- function(df, columns) {
# Ensure 'columns' is a character vector
if(!is.character(columns)) {
stop("columns argument must be a character vector specifying column names to encode")
}
# Check if specified columns exist in the dataframe
if(!all(columns %in% names(df))) {
stop("Not all specified columns exist in the dataframe")
}
# Start with the original dataframe minus the columns to be encoded
result_df <- df[, !(names(df) %in% columns)]
# Iterate over the columns and perform one-hot encoding
for(column in columns) {
# Create a temporary dataframe to avoid altering the original data
temp_df <- data.frame(df[[column]], stringsAsFactors = FALSE)
colnames(temp_df) <- column
# Apply model.matrix(), remove intercept column, and convert to dataframe
encoded_matrix <- model.matrix(~ . - 1, data = temp_df)
encoded_df <- data.frame(encoded_matrix)
# Rename encoded columns to include original column name for clarity
colnames(encoded_df) <- gsub("X", column, colnames(encoded_df))
# Combine with the result dataframe
result_df <- cbind(result_df, encoded_df)
}
return(cbind(df[1], result_df))
}
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "new")
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "old")
View(data_state)
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
filter(!is.na(old)) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
View(data_state)
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
View(data_state)
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
filter(!is.na(old)) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
View(data_state)
# One-hot encode
one_hot_encode <- function(df, columns) {
# Ensure 'columns' is a character vector
if(!is.character(columns)) {
stop("columns argument must be a character vector specifying column names to encode")
}
# Check if specified columns exist in the dataframe
if(!all(columns %in% names(df))) {
stop("Not all specified columns exist in the dataframe")
}
# Start with the original dataframe minus the columns to be encoded
result_df <- df[, !(names(df) %in% columns)]
# Iterate over the columns and perform one-hot encoding
for(column in columns) {
# Create a temporary dataframe to avoid altering the original data
temp_df <- data.frame(df[[column]], stringsAsFactors = FALSE)
colnames(temp_df) <- column
# Apply model.matrix(), remove intercept column, and convert to dataframe
encoded_matrix <- model.matrix(~ . - 1, data = temp_df)
encoded_df <- data.frame(encoded_matrix)
# Rename encoded columns to include original column name for clarity
colnames(encoded_df) <- gsub("X", column, colnames(encoded_df))
# Combine with the result dataframe
result_df <- cbind(result_df, encoded_df)
}
return(cbind(df[1], result_df))
}
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "new")
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "old")
knitr::opts_chunk$set(echo = T,
results = "hide")
libraries = c( "fpp3", "ggplot2", "dplyr", "tidyr", "readxl", "forecast", "zoo", "tsibble", "GGally", "lubridate", "tidyverse", "stringi")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
rm(list=ls())
setwd("C:/Thesis")
# Read system history data
history_data <- read_csv("Data/sys_history_line.csv", locale = locale(encoding = "UTF-8"))
# Convert update_time to POSIXct
history_data$update_time <- as.POSIXct(strptime(history_data$update_time, "%d-%m-%Y %H:%M:%S", tz="UTC"))
# Read all data
data_all <- read_csv("Data/data.csv", locale = locale(encoding = "UTF-8"))
# Merge data by 'set' and 'number'
data <- history_data %>%
mutate(set = trimws(gsub("Case:", " ", set))) %>%
inner_join(select(data_all, number, account, opened, closed, openedToClosed), by = c("set" = "number"))
# Filter out records where update_time is after closed but new is not "Closed"
data <- data %>%
filter(!(update_time > closed & new != "Closed"))
# Calculate time differences
data <- data %>%
mutate(
time_diff_opened = as.numeric(update_time - opened)
)
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
filter(!is.na(old)) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
# One-hot encode
one_hot_encode <- function(df, columns) {
# Ensure 'columns' is a character vector
if(!is.character(columns)) {
stop("columns argument must be a character vector specifying column names to encode")
}
# Check if specified columns exist in the dataframe
if(!all(columns %in% names(df))) {
stop("Not all specified columns exist in the dataframe")
}
# Start with the original dataframe minus the columns to be encoded
result_df <- df[, !(names(df) %in% columns)]
# Iterate over the columns and perform one-hot encoding
for(column in columns) {
# Create a temporary dataframe to avoid altering the original data
temp_df <- data.frame(df[[column]], stringsAsFactors = FALSE)
colnames(temp_df) <- column
# Apply model.matrix(), remove intercept column, and convert to dataframe
encoded_matrix <- model.matrix(~ . - 1, data = temp_df)
encoded_df <- data.frame(encoded_matrix)
# Rename encoded columns to include original column name for clarity
colnames(encoded_df) <- gsub("X", column, colnames(encoded_df))
# Combine with the result dataframe
result_df <- cbind(result_df, encoded_df)
}
return(cbind(df[1], result_df))
}
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "old")
encoded_df_assignment_group <- one_hot_encode(data_assignment_group, "old")
encoded_df_assigned_to <- one_hot_encode(data_assigned_to, "old")
# Simplify column removal
encoded_df_state <- encoded_df_state[-2]
encoded_df_assignmet_group <- encoded_df_assignment_group[-2]
encoded_df_assigned_to <- encoded_df_assigned_to[-2]
# Replace values with percentage
replace_with_percentage <- function(df, percentage_col) {
df[, -c(1, 2)] <- df[, -c(1, 2)] * df[, percentage_col]
df[, -1] <- round(df[, -1], 2)
return(df)
}
encoded_df_state <- replace_with_percentage(encoded_df_state, "percentage_time_diff")
encoded_df_assignmet_group <- replace_with_percentage(encoded_df_assignmet_group, "percentage_time_diff")
encoded_df_assigned_to <- replace_with_percentage(encoded_df_assigned_to, "percentage_time_diff")
# Group by set and sum all columns
summarize_grouped_df <- function(df) {
df <- df %>%
group_by(set) %>%
summarise(across(-1, sum, na.rm = TRUE)) %>%
ungroup()
return(df)
}
grouped_encoded_df_state <- summarize_grouped_df(encoded_df_state)
grouped_encoded_df_assignmet_group <- summarize_grouped_df(encoded_df_assignmet_group)
grouped_encoded_df_assigned_to <- summarize_grouped_df(encoded_df_assigned_to)
# Replace column names
replace_column_names <- function(df, prefix) {
colnames(df) <- gsub("new", prefix, colnames(df))
return(df)
}
grouped_encoded_df_state <- replace_column_names(grouped_encoded_df_state, "prop_state_")
grouped_encoded_df_assignmet_group <- replace_column_names(grouped_encoded_df_assignmet_group, "prop_group_")
grouped_encoded_df_assigned_to <- replace_column_names(grouped_encoded_df_assigned_to, "prop_user_")
# Merge all dataframes
final_df <- Reduce(function(x, y) merge(x, y, by = "set", all = TRUE),
list(grouped_encoded_df_state, grouped_encoded_df_assignmet_group, grouped_encoded_df_assigned_to))
# Rename set to number
colnames(final_df)[1] <- "number"
# Save the final dataframe
write_csv(final_df, "Data/data_proportion.csv")
knitr::opts_chunk$set(echo = TRUE)
libraries = c( "fpp3", "ggplot2", "dplyr", "tidyr", "readxl", "forecast", "zoo", "tsibble", "GGally", "lubridate", "tidyverse", "stringi")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
rm(list=ls())
setwd("C:/Thesis")
cluster_data <- read_csv("Data/data_withclusters.csv", locale = locale(encoding = "UTF-8"))
vect_desc_data <- read_csv("Data/VectorizedText_description.csv", locale = locale(encoding = "UTF-8"))
vect_cause_data <- read_csv("Data/VectorizedText_cause.csv", locale = locale(encoding = "UTF-8"))
vect_clause_notes_data <- read_csv("Data/VectorizedText_close_notes.csv", locale = locale(encoding = "UTF-8"))
proportion_data <- read_csv("Data/data_proportion.csv", locale = locale(encoding = "UTF-8"))
#Merge all data by number
data_all <- cluster_data %>%
inner_join(vect_desc_data, by = c("number" = "number")) %>%
inner_join(vect_cause_data, by = c("number" = "number")) %>%
inner_join(vect_clause_notes_data, by = c("number" = "number")) %>%
inner_join(proportion_data, by = c("number" = "number"))
#save data_all as csv
write.csv(data_all, file = "Data/data_all.csv")
# Make new datafram with columns 1-6 and 20-25
data_prop <- select(data_all, number, prop_state_Resolved)
# Plot top 5 of sum of columns 93:194
data_all %>%
select(93:194) %>%
summarise_all(sum) %>%
gather() %>%
arrange(desc(value)) %>%
head(5) %>%
ggplot(aes(x = fct_reorder(key, value), y = value)) +
geom_col() +
coord_flip() +
labs(title = "Top 5 columns with highest sum", x = "Column", y = "Sum")
# Plot top 5 of sum of columns 93:194
data_all %>%
select(93:188) %>%
summarise_all(sum) %>%
gather() %>%
arrange(desc(value)) %>%
head(5) %>%
ggplot(aes(x = fct_reorder(key, value), y = value)) +
geom_col() +
coord_flip() +
labs(title = "Top 5 columns with highest sum", x = "Column", y = "Sum")
# Replace column names
replace_column_names <- function(df, prefix) {
colnames(df) <- gsub("old", prefix, colnames(df))
return(df)
}
grouped_encoded_df_state <- replace_column_names(grouped_encoded_df_state, "prop_state_")
knitr::opts_chunk$set(echo = T,
results = "hide")
libraries = c( "fpp3", "ggplot2", "dplyr", "tidyr", "readxl", "forecast", "zoo", "tsibble", "GGally", "lubridate", "tidyverse", "stringi")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
rm(list=ls())
setwd("C:/Thesis")
# Read system history data
history_data <- read_csv("Data/sys_history_line.csv", locale = locale(encoding = "UTF-8"))
# Convert update_time to POSIXct
history_data$update_time <- as.POSIXct(strptime(history_data$update_time, "%d-%m-%Y %H:%M:%S", tz="UTC"))
# Read all data
data_all <- read_csv("Data/data.csv", locale = locale(encoding = "UTF-8"))
# Merge data by 'set' and 'number'
data <- history_data %>%
mutate(set = trimws(gsub("Case:", " ", set))) %>%
inner_join(select(data_all, number, account, opened, closed, openedToClosed), by = c("set" = "number"))
# Filter out records where update_time is after closed but new is not "Closed"
data <- data %>%
filter(!(update_time > closed & new != "Closed"))
# Calculate time differences
data <- data %>%
mutate(
time_diff_opened = as.numeric(update_time - opened)
)
# Define function to calculate time differences for different fields
calculate_time_diff <- function(data, field_name) {
data %>%
filter(field == field_name) %>%
arrange(update_time) %>%
group_by(set) %>%
mutate(
time_diff_previous = as.numeric(difftime(update_time, lag(update_time), units = "hours")),
sum_time_diff = sum(time_diff_previous, na.rm = TRUE),
percentage_time_diff = time_diff_previous / sum_time_diff * 100
) %>%
filter(!is.na(old)) %>%
select(set, old, percentage_time_diff) %>%
ungroup()
}
# Apply the function for different fields
data_state <- calculate_time_diff(data, "state")
data_assignment_group <- calculate_time_diff(data, "assignment_group")
data_assigned_to <- calculate_time_diff(data, "assigned_to")
# One-hot encode
one_hot_encode <- function(df, columns) {
# Ensure 'columns' is a character vector
if(!is.character(columns)) {
stop("columns argument must be a character vector specifying column names to encode")
}
# Check if specified columns exist in the dataframe
if(!all(columns %in% names(df))) {
stop("Not all specified columns exist in the dataframe")
}
# Start with the original dataframe minus the columns to be encoded
result_df <- df[, !(names(df) %in% columns)]
# Iterate over the columns and perform one-hot encoding
for(column in columns) {
# Create a temporary dataframe to avoid altering the original data
temp_df <- data.frame(df[[column]], stringsAsFactors = FALSE)
colnames(temp_df) <- column
# Apply model.matrix(), remove intercept column, and convert to dataframe
encoded_matrix <- model.matrix(~ . - 1, data = temp_df)
encoded_df <- data.frame(encoded_matrix)
# Rename encoded columns to include original column name for clarity
colnames(encoded_df) <- gsub("X", column, colnames(encoded_df))
# Combine with the result dataframe
result_df <- cbind(result_df, encoded_df)
}
return(cbind(df[1], result_df))
}
# Apply one-hot encoding for different fields
encoded_df_state <- one_hot_encode(data_state, "old")
encoded_df_assignment_group <- one_hot_encode(data_assignment_group, "old")
encoded_df_assigned_to <- one_hot_encode(data_assigned_to, "old")
# Simplify column removal
encoded_df_state <- encoded_df_state[-2]
encoded_df_assignmet_group <- encoded_df_assignment_group[-2]
encoded_df_assigned_to <- encoded_df_assigned_to[-2]
# Replace values with percentage
replace_with_percentage <- function(df, percentage_col) {
df[, -c(1, 2)] <- df[, -c(1, 2)] * df[, percentage_col]
df[, -1] <- round(df[, -1], 2)
return(df)
}
encoded_df_state <- replace_with_percentage(encoded_df_state, "percentage_time_diff")
encoded_df_assignmet_group <- replace_with_percentage(encoded_df_assignmet_group, "percentage_time_diff")
encoded_df_assigned_to <- replace_with_percentage(encoded_df_assigned_to, "percentage_time_diff")
# Group by set and sum all columns
summarize_grouped_df <- function(df) {
df <- df %>%
group_by(set) %>%
summarise(across(-1, sum, na.rm = TRUE)) %>%
ungroup()
return(df)
}
grouped_encoded_df_state <- summarize_grouped_df(encoded_df_state)
grouped_encoded_df_assignmet_group <- summarize_grouped_df(encoded_df_assignmet_group)
grouped_encoded_df_assigned_to <- summarize_grouped_df(encoded_df_assigned_to)
# Replace column names
replace_column_names <- function(df, prefix) {
colnames(df) <- gsub("old", prefix, colnames(df))
return(df)
}
grouped_encoded_df_state <- replace_column_names(grouped_encoded_df_state, "prop_state_")
grouped_encoded_df_assignmet_group <- replace_column_names(grouped_encoded_df_assignmet_group, "prop_group_")
grouped_encoded_df_assigned_to <- replace_column_names(grouped_encoded_df_assigned_to, "prop_user_")
# Merge all dataframes
final_df <- Reduce(function(x, y) merge(x, y, by = "set", all = TRUE),
list(grouped_encoded_df_state, grouped_encoded_df_assignmet_group, grouped_encoded_df_assigned_to))
# Rename set to number
colnames(final_df)[1] <- "number"
# Save the final dataframe
write_csv(final_df, "Data/data_proportion.csv")
knitr::opts_chunk$set(echo = TRUE)
libraries = c( "fpp3", "ggplot2", "dplyr", "tidyr", "readxl", "forecast", "zoo", "tsibble", "GGally", "lubridate", "tidyverse", "stringi")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
rm(list=ls())
setwd("C:/Thesis")
cluster_data <- read_csv("Data/data_withclusters.csv", locale = locale(encoding = "UTF-8"))
vect_desc_data <- read_csv("Data/VectorizedText_description.csv", locale = locale(encoding = "UTF-8"))
vect_cause_data <- read_csv("Data/VectorizedText_cause.csv", locale = locale(encoding = "UTF-8"))
vect_clause_notes_data <- read_csv("Data/VectorizedText_close_notes.csv", locale = locale(encoding = "UTF-8"))
proportion_data <- read_csv("Data/data_proportion.csv", locale = locale(encoding = "UTF-8"))
#Merge all data by number
data_all <- cluster_data %>%
inner_join(vect_desc_data, by = c("number" = "number")) %>%
inner_join(vect_cause_data, by = c("number" = "number")) %>%
inner_join(vect_clause_notes_data, by = c("number" = "number")) %>%
inner_join(proportion_data, by = c("number" = "number"))
#save data_all as csv
write.csv(data_all, file = "Data/data_all.csv")
# Make new datafram with columns 1-6 and 20-25
data_prop <- select(data_all, number, prop_state_Resolved)
# Plot top 5 of sum of columns 93:194
data_all %>%
select(93:188) %>%
summarise_all(sum) %>%
gather() %>%
arrange(desc(value)) %>%
head(5) %>%
ggplot(aes(x = fct_reorder(key, value), y = value)) +
geom_col() +
coord_flip() +
labs(title = "Top 5 columns with highest sum", x = "Column", y = "Sum")
