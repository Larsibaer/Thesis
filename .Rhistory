#Merge all data by number
data_all <- data %>%
inner_join(cluster_data, by = c("number" = "number")) %>%
inner_join(topic_model_data, by = c("number" = "number")) %>%
inner_join(vect_desc_data, by = c("number" = "number")) %>%
inner_join(vect_cause_data, by = c("number" = "number")) %>%
inner_join(vect_clause_notes_data, by = c("number" = "number")) %>%
inner_join(proportion_data, by = c("number" = "number"))
# Do a copy of data_all and replace "Unico" with FuBar
data_gpt <- data_all
data_gpt$created_by_group[data_gpt$created_by_group == "Unico"] <- "FuBar"
#Rplace the column account with a Substring of the last 3 letters
data_gpt$account <-  paste0(substr(data_gpt$account, 1, 2), substr(data_gpt$account, nchar(data_gpt$account)-3, nchar(data_gpt$account)))
#Save file without index
write.csv(data_gpt, "Data/data_gpt.csv", row.names = FALSE)
View(data_gpt)
###################################################################################################
### TOPIC MODELING
### (c) Patrick Cichy, Berner Fachhochschule BFH
###################################################################################################
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 1: LOAD PACKAGES AND SET WORKING DIRECTORY
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
library(tidyverse)
library(quanteda)
library(stopwords)
library(topicmodels)
library(tidytext)
library(quanteda.textplots)
options(scipen=999)
rm(list=ls())
# Set working directory
setwd("C:/Thesis")
#read json file
cases_data <- read_csv("Data/TopicModel_VectorizedText_description.csv", locale = locale(encoding = "UTF-8"))
reviews <- cases_data
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 2: LOAD AND SELECT DATA (E.G. AMAZON REVIEWS)
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# OPTIONAL: Specify minimum text length (number of characters)
reviews <- subset(reviews, reviews$description > 100)
# remove NAs in description
reviews <- reviews[!is.na(reviews$description),]
# OPTIONAL: Further selection (select variable to filter)
# reviews<- subset(reviews, reviews$product == "Fitbit Charge 2")
# OPTIONAL: Create random sample
# reviews <- sample_n(reviews, 1000)
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 3: PREPARE TEXT DATA (TEXT PRE-PROCESSING)
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Remove all "-" where they are not needed
reviews$description <- gsub("-", " ", reviews$description)
# Transform words into tokens, select basic text preprocessing steps
tokens <- tokens(reviews$description,
remove_punct = TRUE,
remove_symbols = TRUE,
remove_numbers = TRUE,
remove_url = TRUE,
remove_separators = TRUE)
# Create n-grams of any length
tokens <- tokens_ngrams(tokens, n = 1:2)
# Create Document-feature-matrix
myDfm <-dfm(tokens)
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 4: ANALYZE TEXT
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create LDA model (specify number of topics)
reviews_lda <- LDA(myDfm, k = 6, control = list(seed = 123))
topics <- as.data.frame(terms(reviews_lda, 50))
# Convert into tidy-format to visualize results
reviews_lda_td <- tidy(reviews_lda)
# Extract top-terms per topic
top_terms <- reviews_lda_td %>%
group_by(topic) %>%
top_n(10, beta) %>%
ungroup() %>%
arrange(topic, -beta)
# Visualize top-terms and their loadings (can you assign topic labels based on this information?)
top_terms %>%
mutate(term = reorder(term, beta)) %>%
ggplot(aes(term, beta, fill = factor(topic))) +
geom_bar(alpha = 0.8, stat = "identity", show.legend = FALSE) +
facet_wrap(~ topic, scales = "free") +
coord_flip()
# Link results to metadata
tmResult <- posterior(reviews_lda)
theta <- tmResult$topics
lda_results <- cbind(reviews, theta)
rm (theta, reviews_lda,reviews_lda_td,tmResult,top_terms,tokens)
# add all rows from cases_data to lda_results, where number is missing and add the value 0 to all topics
lda_results <- lda_results[-2] %>%
full_join(cases_data, by = "number")
# fill NA with 0
lda_results[is.na(lda_results)] <- 0
# remove last column
lda_results <- lda_results[-ncol(lda_results)]
# rename columns
# Save the final dataframe
write_csv(lda_results, "Data/topicModel_description.csv")
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 5: GO BACK TO STEP 3 AND 4 TO RECONSIDER PREPROCESSING, STOPWORDS AND THE NUMBER OF TOPICS.
###         ITERATE MULTIPLE TIMES AND OBSERVE HOW RESULTS CHANGE. GOOD LUCK!
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### OPTIONAL: CHOOSE THE BEST NUMBER OF TOPICS BASED ON A METRIC
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
library (ldatuning)
### Calculate different metrics to estimate the most preferable number of topics for LDA model
## Be aware: The procedure is computation intensive
# ldatuning uses parallelism, specify the correct number of CPU cores in mc.core parameter to archive best performance
# Calculate selected metrics
result <- FindTopicsNumber(
myDfm,
topics = seq(from = 2, to = 10, by = 1),
metrics = c("Griffiths2004", "CaoJuan2009", "Arun2010", "Deveaud2014"),
method = "Gibbs",
control = list(seed = 77),
mc.cores = 2L,
verbose = TRUE)
# plot results
FindTopicsNumber_plot(result)
###################################################################################################
### Wordclouds
### (c) Patrick Cichy, Berner Fachhochschule BFH
###################################################################################################
# Create a wordcloud from your Document-Feature-Matrix
textplot_wordcloud(myDfm,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
View(topics)
# Create a wordcloud for each topic
textplot_wordcloud(reviews_lda,
topic = 1,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud for each topic
textplot_wordcloud(myDfm,
topic = 1,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud for each topic
textplot_wordcloud(myDfm,
topic = 2,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud for each topic
textplot_wordcloud(myDfm,
topic = 1,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud for each topic
textplot_wordcloud(myDfm,
topic = 4,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud from DFM with specific topic
textplot_wordcloud(myDfm, topic = 1,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 300,
color = "darkblue")
# Create a wordcloud from DFM with specific topic
textplot_wordcloud(myDfm, topic = 1,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 50,
color = "darkblue")
# Create a wordcloud from DFM with specific topic
textplot_wordcloud(myDfm, topic = 2,
min_size = 0.5,
max_size = 4,
min_count = 10,
max_words = 50,
color = "darkblue")
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### STEP 4: ANALYZE TEXT
### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create LDA model (specify number of topics)
reviews_lda <- LDA(myDfm, k = 6, control = list(seed = 123))
View(topics)
# Rename columns
colnames(lda_results) <- c("number", "Desktop_Issues", "VDI_Troubleshooting", "Functionality_Problems", "Hardware_Concerns", "Login_Access", "Email_Communication")
# Save the final dataframe
write_csv(lda_results, "Data/topicModel_description.csv")
rm(list=ls())
setwd("C:/Thesis")
data <- read_csv("Data/data.csv", locale = locale(encoding = "UTF-8"))
cluster_data <- read_csv("Data/data_withclusters.csv", locale = locale(encoding = "UTF-8"))
topic_model_data <- read_csv("Data/topicModel_description.csv", locale = locale(encoding = "UTF-8"))
vect_desc_data <- read_csv("Data/VectorizedText_description.csv", locale = locale(encoding = "UTF-8"))
vect_cause_data <- read_csv("Data/VectorizedText_cause.csv", locale = locale(encoding = "UTF-8"))
vect_clause_notes_data <- read_csv("Data/VectorizedText_close_notes.csv", locale = locale(encoding = "UTF-8"))
proportion_data <- read_csv("Data/data_proportion.csv", locale = locale(encoding = "UTF-8"))
#Merge all data by number
data_all <- data %>%
inner_join(cluster_data, by = c("number" = "number")) %>%
inner_join(topic_model_data, by = c("number" = "number")) %>%
inner_join(vect_desc_data, by = c("number" = "number")) %>%
inner_join(vect_cause_data, by = c("number" = "number")) %>%
inner_join(vect_clause_notes_data, by = c("number" = "number")) %>%
inner_join(proportion_data, by = c("number" = "number"))
View(data_all)
# Do a copy of data_all and replace "Unico" with FuBar
data_gpt <- data_all
data_gpt$created_by_group[data_gpt$created_by_group == "Unico"] <- "FuBar"
#Rplace the column account with a Substring of the last 3 letters
data_gpt$account <-  paste0(substr(data_gpt$account, 1, 2), substr(data_gpt$account, nchar(data_gpt$account)-3, nchar(data_gpt$account)))
#Save file without index
write.csv(data_gpt, "Data/data_gpt.csv", row.names = FALSE)
View(data_gpt)
View(data_gpt)
#remove columns 17-19
data_gpt <- data_gpt[,-c(17:19)]
#Save file without index
write.csv(data_gpt, "Data/data_gpt.csv", row.names = FALSE)
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("^prop_group_", names(data), value = TRUE)
cluster_1_5 <- data %>%
filter(cluster %in% c(1, 5))
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("^prop_group_", names(data), value = TRUE)
cluster_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Assuming clusters_1_5 is a dataframe that contains only the data for clusters 1 and 5
# You might need to create this dataframe as follows:
# clusters_1_5 <- data %>% filter(cluster %in% c(1, 5))
# Analyze the group involvement specifically for clusters 1 and 5
group_involvement_stats <- clusters_1_5 %>%
select(all_of(group_columns)) %>%
summary()
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("^prop_group_", names(data), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Assuming clusters_1_5 is a dataframe that contains only the data for clusters 1 and 5
# You might need to create this dataframe as follows:
# clusters_1_5 <- data %>% filter(cluster %in% c(1, 5))
# Analyze the group involvement specifically for clusters 1 and 5
group_involvement_stats <- clusters_1_5 %>%
select(all_of(group_columns)) %>%
summary()
# Display the descriptive statistics
group_involvement_stats
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("prop_group_", names(data), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Assuming clusters_1_5 is a dataframe that contains only the data for clusters 1 and 5
# You might need to create this dataframe as follows:
# clusters_1_5 <- data %>% filter(cluster %in% c(1, 5))
# Analyze the group involvement specifically for clusters 1 and 5
group_involvement_stats <- clusters_1_5 %>%
select(all_of(group_columns)) %>%
summary()
# Display the descriptive statistics
group_involvement_stats
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("prop_group_", names(data_all), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Assuming clusters_1_5 is a dataframe that contains only the data for clusters 1 and 5
# You might need to create this dataframe as follows:
# clusters_1_5 <- data %>% filter(cluster %in% c(1, 5))
# Analyze the group involvement specifically for clusters 1 and 5
group_involvement_stats <- clusters_1_5 %>%
select(all_of(group_columns)) %>%
summary()
# Display the descriptive statistics
group_involvement_stats
#Plotting the group involvement for clusters 1 and 5
group_involvement_stats %>%
gather() %>%
ggplot(aes(x = key, y = value)) +
geom_boxplot(fill = "lightblue", color = "blue") +
labs(x = "Group", y = "Proportion of Involvement", title = "Group Involvement in Clusters 1 and 5") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
#Plotting the group involvement for clusters 1 and 5
group_involvement_stats %>%
ggplot(aes(x = key, y = value)) +
geom_boxplot(fill = "lightblue", color = "blue") +
labs(x = "Group", y = "Proportion of Involvement", title = "Group Involvement in Clusters 1 and 5") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Calculate the correlation between 'openedToClosed' and the group involvement columns
correlation_with_opened_to_closed <- cor(clusters_1_5[, c("openedToClosed", group_columns)])
# Extract the correlations of 'openedToClosed' with group columns
correlation_with_opened_to_closed <- correlation_with_opened_to_closed["openedToClosed", -1]
# Print the correlation results
correlation_with_opened_to_closed
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45, # Rotate labels for better readability
title = "Correlation between OpenedToClosed and Group Involvement Columns")
library(corrplot)
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45, # Rotate labels for better readability
title = "Correlation between OpenedToClosed and Group Involvement Columns")
correlation_matrix <- cor(clusters_1_5[, c("openedToClosed", group_columns)])
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45, # Rotate labels for better readability
title = "Correlation between OpenedToClosed and Group Involvement Columns")
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("prop_group_", names(data_all), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Assuming clusters_1_5 is a dataframe that contains only the data for clusters 1 and 5
# You might need to create this dataframe as follows:
# clusters_1_5 <- data %>% filter(cluster %in% c(1, 5))
# Analyze the group involvement specifically for clusters 1 and 5
group_involvement_stats <- clusters_1_5 %>%
select(all_of(group_columns)) %>%
summary()
# Display the descriptive statistics
group_involvement_stats
#Plotting the group involvement for clusters 1 and 5
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = most_responsible_group)) +
geom_histogram(binwidth = 1, position = "dodge") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
group_index <- grep("prop_group_", colnames(data_all))
# Make new Column of most responsle group. Look in the columns of group_index, if there is a value > 50, then assign the column name to the new column, else assign "Other"
data_all$most_responsible_group <- apply(data_all[group_index], 1, function(x) {
ifelse(max(x, na.rm = TRUE) > 50, names(x)[which.max(x)], "Other")
})
description_index <- grep("description_", colnames(data_all))
cause_index <- grep("cause_", colnames(data_all))
close_notes_index <- grep("close_notes_", colnames(data_all))
# Remove prop_group_ of column names
colnames(data_all) <- gsub("close_notes_", "close_", colnames(data_all))
# Reshape from wide to long format and create a new 'term_type' column
data_long <- data_all %>%
pivot_longer(
cols = c(description_index, cause_index, close_notes_index),
names_to = c("term_type", "term"),
names_sep = "_",  # Split column names at underscores
values_to = "tf_idf"
)
data_long <- data_long %>% filter(tf_idf > 0)  # Remove rows with 0 values
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("prop_group_", names(data_all), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = most_responsible_group)) +
geom_histogram(binwidth = 1, position = "dodge") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Identify all columns that relate to group involvement, which are prefixed with 'prop_group_'
group_columns <- grep("prop_group_", names(data_all), value = TRUE)
clusters_1_5 <- data_all %>%
filter(cluster %in% c(1, 5))
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = most_responsible_group)) +
geom_histogram(binwidth = 100, position = "dodge") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
View(clusters_1_5)
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = most_responsible_group)) +
geom_histogram(binwidth = 100) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = most_responsible_group)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$Desktop_Issues)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$VDI_Troubleshooting)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$Functionality_Problems)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$Hardware_Concerns)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$Login_Access)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = cluster_1_5$Desktop_Issues)) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = factor(Desktop_Issues))) +
geom_histogram(binwidth = 50) +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
View(clusters_1_5)
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(binwidth = 50, alpha = 0.8) +
scale_fill_gradient(low = "red1", high = "darkred") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(binwidth = 50, alpha = 0.8) +
scale_fill_gradient(low = "red1", high = "darkred") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
View(clusters_1_5)
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(binwidth = 50, alpha = 0.8) +
scale_fill_gradient(low = "red", high = "darkred") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(binwidth = 50, alpha = 0.8) +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(binwidth = 40, alpha = 0.8) +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = factor(Desktop_Issues))) +
geom_histogram(bins = 30, color = "black") +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = Desktop_Issues, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot histogram of openedToClosed filled by Desktop_issues
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +
scale_fill_gradient(low = "red", high = "blue") +
labs(x = "Opened to Closed Duration", y = "Frequency", title = "Distribution of Opened to Closed Duration by Group for Clusters 1 and 5") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +  # Adjust the number of bins as needed
scale_fill_gradient(low = "red", high = "darkred") +  # Gradient from bright red to dark red
labs(title = "Histogram of Time to Close Issues", x = "Time Opened to Closed", y = "Frequency") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(data_all, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +  # Adjust the number of bins as needed
scale_fill_gradient(low = "red", high = "darkred") +  # Gradient from bright red to dark red
labs(title = "Histogram of Time to Close Issues", x = "Time Opened to Closed", y = "Frequency") +
theme_minimal()
summary(data$Desktop_Issues)
summary(clusters_1_5$Desktop_Issues)
clusters_1_5$Desktop_Issues <- as.numeric(clusters_1_5$Desktop_Issues)
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black") +  # Adjust the number of bins as needed
scale_fill_gradient(low = "red", high = "darkred") +
labs(title = "Histogram of Time to Close Issues", x = "Time Opened to Closed", y = "Frequency") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(data, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black", boundary = 0, closed = "left") +  # Explicit bin settings
scale_fill_gradient(low = "red", high = "darkred",
limits = c(min(data$Desktop_Issues, na.rm = TRUE), max(data$Desktop_Issues, na.rm = TRUE)),
na.value = "grey", oob = scales::squish) +  # Adjust gradient limits and handle out of bounds
labs(title = "Histogram of Time to Close Issues", x = "Time Opened to Closed", y = "Frequency") +
theme_minimal()
# Plot an histogram of the 'openedToClosed' duration for clusters 1 and 5. Fill color by group
ggplot(clusters_1_5, aes(x = openedToClosed, fill = Desktop_Issues)) +
geom_histogram(bins = 30, color = "black", boundary = 0, closed = "left") +  # Explicit bin settings
scale_fill_gradient(low = "red", high = "darkred",
limits = c(min(data$Desktop_Issues, na.rm = TRUE), max(data$Desktop_Issues, na.rm = TRUE)),
na.value = "grey", oob = scales::squish) +  # Adjust gradient limits and handle out of bounds
labs(title = "Histogram of Time to Close Issues", x = "Time Opened to Closed", y = "Frequency") +
theme_minimal()
